<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vanilla JS——世界上最轻量的JavaScript框架（没有之一）</title>
      <link href="2021/04/02/Vanilla%20JS%E2%80%94%E2%80%94%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E8%BD%BB%E9%87%8F%E7%9A%84JavaScript%E6%A1%86%E6%9E%B6%EF%BC%88%E6%B2%A1%E6%9C%89%E4%B9%8B%E4%B8%80%EF%BC%89/"/>
      <url>2021/04/02/Vanilla%20JS%E2%80%94%E2%80%94%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E8%BD%BB%E9%87%8F%E7%9A%84JavaScript%E6%A1%86%E6%9E%B6%EF%BC%88%E6%B2%A1%E6%9C%89%E4%B9%8B%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>Vanilla JS 是一个快速、轻量级、跨平台的JavaScript框架。我们可以用它构建强大的JavaScript应用程序。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><hr><p>Vanilla JS小巧而符合直觉。<br>有哪些企业采用了Vanilla JS？很多，很多，下面只是其中最知名的一部分：</p><ul><li>Facebook</li><li>Google</li><li>YouTube</li><li>Yahoo</li><li>Wikipedia</li><li>Windows Live</li><li>Twitter Amazon</li><li>LinkedIn</li><li>MSN</li><li>eBay</li><li>Microsoft</li><li>Tumblr</li><li>Apple</li><li>Pinterest</li><li>PayPal</li><li>Reddit</li><li>Netflix</li><li>Stack Overflow<br>实际上, 使用 Vanilla JS 的网站比使用jQuery、Prototype JS、MooTools、YUI 和 Google Web Toolkit 的网站加起来还要多.</li></ul><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><hr><p>Vanilla JS是世界上最轻量的javascript 框架（沒有之一），使用我们的产品部署策略，你的用户的浏览器向你的站点发送请求前就已经把Vanilla JS加载在浏览器里了。<br>使用Vanilla JS只需在应用的HTML里加入这行：</p><pre><code>&lt;script src=&quot;path/to/vanilla.js&quot;&gt;&lt;/script&gt;</code></pre><p>当你部署你的应用的时候，使用这个更快的方法：</p><pre><code></code></pre><p>你没看错！没有任何代码，Vanilla JS 太流行了，所有的浏览器在十年前就已经内置了它。</p><h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><hr><p>看看Vanilla JS到底有多快：</p><h3 id="根据ID获取DOM元素"><a href="#根据ID获取DOM元素" class="headerlink" title="根据ID获取DOM元素"></a>根据ID获取DOM元素</h3><table><thead><tr><th>框架</th><th>代码</th><th style="text-align:center">次数/秒</th></tr></thead><tbody><tr><td>Vanilla JS</td><td>document.getElementById(‘test-table’);</td><td style="text-align:center">12,137,211</td></tr><tr><td>Dojo</td><td>dojo.byId(‘test-table’);</td><td style="text-align:center">5,443,343</td></tr><tr><td>Prototype JS</td><td>$(‘test-table’)</td><td style="text-align:center">2,940,734</td></tr><tr><td>Ext JS</td><td>delete Ext.elCache[‘test-table’]; Ext.get(‘test-table’);</td><td style="text-align:center">997,562</td></tr><tr><td>jQuery</td><td>$jq(‘#test-table’);</td><td style="text-align:center">350,557</td></tr><tr><td>YUI</td><td>YAHOO.util.Dom.get(‘test-table’);</td><td style="text-align:center">326,534</td></tr><tr><td>MooTools</td><td>document.id(‘test-table’);</td><td style="text-align:center">78,802</td></tr></tbody></table><h3 id="根据标签名获取DOM元素"><a href="#根据标签名获取DOM元素" class="headerlink" title="根据标签名获取DOM元素"></a>根据标签名获取DOM元素</h3><table><thead><tr><th>框架</th><th>代码</th><th style="text-align:center">次数/秒</th></tr></thead><tbody><tr><td>Vanilla JS</td><td>document.getElementsByTagName(“span”);</td><td style="text-align:center">8,280,893</td></tr><tr><td>Prototype JS</td><td>Prototype.Selector.select(‘span’, document);</td><td style="text-align:center">62,872</td></tr><tr><td>Ext JS</td><td>Ext.query(‘span’);</td><td style="text-align:center">46,915</td></tr><tr><td>YUI</td><td>YAHOO.util.Dom.getElementsBy(function(){return true;},’span’);</td><td style="text-align:center">48,545</td></tr><tr><td>jQuery</td><td>$jq(‘span’);</td><td style="text-align:center">19,449</td></tr><tr><td>Dojo</td><td>dojo.query(‘span’);</td><td style="text-align:center">10,335</td></tr><tr><td>MooTools</td><td>Slick.search(document, ‘span’, new Elements);</td><td style="text-align:center">5,457</td></tr></tbody></table><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><hr><p>下面是一些常见任务的例子，可以看下Vanilla JS和jQuery的区别：</p><h3 id="淡出元素"><a href="#淡出元素" class="headerlink" title="淡出元素"></a>淡出元素</h3><p>Vanilla JS</p><pre><code>var s = document.getElementById(&#39;thing&#39;).style;s.opacity = 1;(function fade()&#123;(s.opacity-=.1)&lt;0?s.display=&quot;none&quot;:setTimeout(fade,40)&#125;)();</code></pre><p>jQuery</p><pre><code>&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(&#39;#thing&#39;).fadeOut();&lt;/script&gt;</code></pre><h3 id="AJAX请求"><a href="#AJAX请求" class="headerlink" title="AJAX请求"></a>AJAX请求</h3><p>Vanilla JS</p><pre><code>var r = new XMLHttpRequest();r.open(&quot;POST&quot;, &quot;path/to/api&quot;, true);r.onreadystatechange = function () &#123;  if (r.readyState != 4 || r.status != 200) return;  alert(&quot;Success: &quot; + r.responseText);&#125;;r.send(&quot;banana=yellow&quot;);</code></pre><p>jQuery</p><pre><code>&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$.ajax(&#123;  type: &#39;POST&#39;,  url: &quot;path/to/api&quot;,  data: &quot;banana=yellow&quot;,  success: function (data) &#123;    alert(&quot;Success: &quot; + data);  &#125;,&#125;);&lt;/script&gt;</code></pre><p>致不敢相信的读者： 请把“Vanilla JS 是世界上最轻量的JavaScript框架（没有之一）”这句话读三遍。如果还是不信的话，再把下面这句话读三遍：“无论过去、现在还是未来，Vanilla JS 都是世界上最轻量的JavaScript框架（没有之一）！”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的Chrome调试工具技巧集合</title>
      <link href="2019/01/28/chrome%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7%E9%9B%86%E5%90%88/"/>
      <url>2019/01/28/chrome%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E6%8A%80%E5%B7%A7%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="Console中的’-’"><a href="#Console中的’-’" class="headerlink" title="Console中的’$’"></a>Console中的’$’</h2><ol><li>$0  <blockquote><p>$可以保存5次对于dom节点的选择操作，$0是最近一次选中的节点，$1是上一次选中的dom节点，直到$4</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/16785c75b56d3a80?imageslim" alt="图片1"></p><ol start="2"><li><p><code>$</code>和<code>$$</code></p><blockquote><p>如果<code>$</code>没有被占用的话（比如jquery或者zepto），在<code>console</code>中相当于<code>document.querySelector</code>的别名<br><code>$$</code>则相当于<code>document.querySelectorAll</code>，且返回的是节点数组而非 Node List</p></blockquote></li><li><p><code>$_</code>  </p><blockquote><p><code>$_</code>是对上次执行结果的引用</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/16785d333e7c1d7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片2"></p><ol start="4"><li><code>$i</code>  <blockquote><p>在<a href="https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related的帮助下" target="_blank" rel="noopener">Chrome插件: Console Importer</a>，可以款速的在<code>console</code>中引入<code>npm</code>库<br>比如直接<code>$i(&#39;lodash&#39;)</code>或<code>$i(&#39;moment&#39;)</code>几秒钟之后，就可以获取到<code>lodash / moment</code>了<br>（对于有的网站 是有CSP安全策略的，这时候加载外部资料是有限制的，加载不成功的）</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/16785da0dea963fb?imageslim" alt="图片3"></p><h2 id="copy-amp-saving"><a href="#copy-amp-saving" class="headerlink" title="copy &amp; saving"></a>copy &amp; saving</h2><ol start="5"><li><code>copy(...)</code>  <blockquote><p>通过全局方法<code>copy()</code>可以在<code>console</code>中<code>copy</code>一切你能拿到的资源，包含<code>$</code>类引用的变量，例如<code>copy($_)</code>或者<code>copy($0)</code></p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/16787442a1444125?imageslim" alt="图片4"></p><ol start="6"><li>Store as global<blockquote><p>当你使用<code>console</code>打印出一堆数据的时候，你希望对这些变量进行一些额外的操作，只需要对这行数据右键单击，选择<code>Store as global variable</code>，就会创建一个<code>tempX</code>的变量，进行后续操作，且不用担心原始数据被重写</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/167874429e8b8f73?imageslim" alt="图片5"></p><h2 id="Console-Methods"><a href="#Console-Methods" class="headerlink" title="Console Methods"></a>Console Methods</h2><ol start="7"><li><code>console.assert</code><blockquote><p>如果断言为false，则将一个错误消息写入控制台。如果断言是true，没有任何反应。</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.assert(assertion, obj1 [, obj2, ..., objN]);</span><br><span class="line"><span class="built_in">console</span>.assert(assertion, msg [, subst1, ..., substN]); <span class="comment">// c-like message formatting</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/167893640b5cdd71?imageslim" alt="图片6"></p><ol start="8"><li><code>console.table</code><blockquote><p><code>console.table</code>会将一个Array、类Array类型或者Object类型的数据以漂亮的表格形式打印出来</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/167893640e9ba1d3?imageslim" alt="图片7"></p><ol start="9"><li><code>console.dir</code><blockquote><p>当我们希望打印dom节点的时候，使用<code>console.log</code>会有局限性。这时我们可以使用<code>console.dir</code>方法，这个方法可以将dom节点以JavaScript对象的方式在控制台打印出来</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/7/1678936410bb79fa?imageslim" alt="图片8"></p><h2 id="The-Elements-panel"><a href="#The-Elements-panel" class="headerlink" title="The Elements panel"></a>The Elements panel</h2><ol start="10"><li><code>h</code>快捷键<blockquote><p>可以通过<code>h</code>快捷键来快速隐藏选中的元素</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/9/1679379780c11ef3?imageslim" alt="图片9"></p><ol start="11"><li>drag &amp; drop elements<blockquote><p>可以通过拖拽dom元素使之放置在相应的节点</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/9/16793797bde74b62?imageslim" alt="图片10"></p><h2 id="让人疑惑的console-log"><a href="#让人疑惑的console-log" class="headerlink" title="让人疑惑的console.log"></a>让人疑惑的<code>console.log</code></h2><ol start="12"><li><code>console.log</code>有时打印出与预期不符的对象<blockquote><p>在<code>console</code>中打印的对象，在打印之前，都是以引用的形式保存的</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/11/1679a0d3a708ef3e?imageslim" alt="图片11"></p><h2 id="Command菜单"><a href="#Command菜单" class="headerlink" title="Command菜单"></a>Command菜单</h2><p>// TODO</p><h2 id="异步console的调试技巧"><a href="#异步console的调试技巧" class="headerlink" title="异步console的调试技巧"></a>异步console的调试技巧</h2><ol start="13"><li>使用console异步调试<blockquote><p>越来越多与浏览器有关的API都是 基于<code>Promise</code>的 。当你使用 <code>promise</code> 的时候你通常使用 <code>.then(处理方法)</code> 或者 将它 ( <code>promise</code> ) 包裹在 async 方法中，并且使用 await 来接收它的结果。  </p></blockquote></li></ol><blockquote><p>我们在 <code>JavaScript/TypeScript</code> 中大量使用这些东西，但是在 <code>Console</code> 中书写这样的结构，一点都不方便。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/12/1679e0201c187733?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片12"></p><blockquote><p>然后，其实你可以直接这样使用</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/12/1679e0201c5c5fd7?imageslim" alt="图片13"></p><h2 id="Color-Picker"><a href="#Color-Picker" class="headerlink" title="Color Picker"></a>Color Picker</h2><ol start="14"><li>Color Picker使用方法  </li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/12/167a1d2cc62a8d0f?imageslim" alt="图片14"></p><h2 id="给-console-计时"><a href="#给-console-计时" class="headerlink" title="给 console 计时"></a>给 <code>console</code> 计时</h2><ol start="15"><li>检测执行时间</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time() <span class="comment">// 开启一个时间器</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd() <span class="comment">// 结束计时并将结果打印出来</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/12/13/167a484d3824545d?imageslim" alt="图片15"><br></p><h2 id="样式编辑器"><a href="#样式编辑器" class="headerlink" title="样式编辑器"></a>样式编辑器</h2><ol start="16"><li>插入样式规则的按钮<blockquote><p>当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个按钮，它们可以让你快速的使用 Color 和 Shadow 编辑器添加 CSS 属性。</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/14/167ac1748b954754?imageslim" alt="图片16"></p><ol start="17"><li>阴影编辑器</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/14/167ac17a4194c870?imageslim" alt="图片17"></p><h2 id="对象-amp-方法"><a href="#对象-amp-方法" class="headerlink" title="对象 &amp; 方法"></a>对象 &amp; 方法</h2><ol start="18"><li><code>queryObjects function</code> 对象查询方法</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/18/167c07a88c45b6bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片18"></p><blockquote><p>假如我们有这样一段代码，我们在里面定义了一些对象。name在特定的上下文中，有哪些存在的对象呢。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/18/167c07a88ed68f7f?imageslim" alt="图片19"></p><ol start="19"><li>给<code>console.log</code>加上<code>css</code>样式</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/12/20/167c99ea0788464b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片20"></p><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><ol start="20"><li>DOM 断点<blockquote><p>某些脚本会修改 DOM 的一部分，不确定修改的是哪部分，甚至不确定是什么时候修改的。<br>添加一个 DOM 断点。你就可以监听到节点被添加或者移除，或属性被改变。</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/168746caeae2a94e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片21"></p><blockquote><p>当断点添加过多或者子元素断点被父元素折叠的时候，在<code>Element</code>中会被高亮展示</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/168747517998eb7d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片22"></p><ol start="21"><li>XHR/fetch 断点<blockquote><p>当你想捕获已发送的 <code>ajax</code> 请求中的特定时刻， 可以使用 XHR/fetch breakpoint。<br>这些只能在 Source 面板中设置。（Network 面板中不可以）</p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16874662814db12c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图片22"></p><h2 id="The-NinJa-logs"><a href="#The-NinJa-logs" class="headerlink" title="The NinJa logs"></a>The NinJa logs</h2><ol start="22"><li>条件断点<blockquote><p>当有一个循环对 200 个元素的遍历，但你只对第 110 次循环的结果感兴趣，或者只对一些满足其他的特殊条件的结果感兴趣时，就需要一个条件断点。</p></blockquote></li></ol><ul><li>右击行号并且选择 <code>Add conditional breakpoint...</code> 的选项</li><li>或者右击一个已经设置的断点并且选择 <code>Edit breakpoint</code></li><li>然后输入一个执行结果为 <code>true</code> 或者 <code>false</code> 的表达式（其实会有隐式转换的）。</li></ul><p>之后，满足条件，断点就会执行</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/17/167b94b8f36112b7?imageslim" alt="图片22"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="2019/01/21/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2019/01/21/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><pre><code class="bash">docker images          # 列出所有镜像(images)docker ps              # 列出正在运行的容器(containers)docker ps -a           # 列出所有的容器docker pull xxx        # 下载xxx镜像docker top &lt;container&gt; # 查看容器内部运行的程序</code></pre><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><pre><code class="bash">docker stop &lt;container&gt;                  # 停止一个正在运行的容器，&lt;container&gt;可以是容器ID或名称docker start &lt;container&gt;                 # 启动一个已经停止的容器docker restart &lt;container&gt;               # 重启容器docker rm &lt;container&gt;                    # 删除容器docker run -i -t -p :80 LAMP /bin/bash   # 运行容器并做http端口转发docker exec -it &lt;container&gt; /bin/bash    # 进入ubuntu类容器的bashdocker exec -it &lt;container&gt; /bin/sh      # 进入alpine类容器的shdocker rm `docker ps -a -q`              # 删除所有已经停止的容器docker kill $(docker ps -a -q)           # 杀死所有正在运行的容器，$()功能同``</code></pre><h2 id="提交-导出"><a href="#提交-导出" class="headerlink" title="提交/导出"></a>提交/导出</h2><pre><code class="bash">docker build --rm=true -t hjue/lamp .    # 建立映像文件。–rm 选项是告诉Docker，在构建完成后删除临时的Container，Dockerfile的每一行指令都会创建一个临时的Container，一般这些临时生成的Container是不需要的docker commit xxxxxxxxxxx mynewimage    # 提交你的变更，并且把容器保存成镜像，命名为mynewimage，xxxxxxxxxxx为容器的IDdocker save mynewimage | bzip2 -9 -c&gt; /home/save.tar.bz2  # 把 mynewimage 镜像保存成 tar 文件bzip2 -d -c &lt; /home/save.tar.bz2 | docker load            # 加载 mynewimage 镜像docker export &lt;CONTAINER ID&gt; &gt; /home/export.tar           # 导出Imagecat /home/export.tar | sudo docker import - mynewimage    # 导入Image镜像</code></pre><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><pre><code class="bash">docker run -i -t centos /bin/bash          # 运行centos镜像docker run -d -p 80:80 hjue/centos-lamp    # 运行centos-lamp镜像docker rmi [image-id]                      # 删除镜像docker rmi $(docker images -q)             # 删除所有镜像docker rmi $(sudo docker images --filter &quot;dangling=true&quot; -q --no-trunc)  # 删除无用镜像</code></pre><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><pre><code class="bash">docker run --help</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack4从零新建react项目流程及踩坑</title>
      <link href="2018/12/11/webpack4%E4%BB%8E%E9%9B%B6%E6%96%B0%E5%BB%BAreact%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E5%8F%8A%E9%87%87%E5%9D%91/"/>
      <url>2018/12/11/webpack4%E4%BB%8E%E9%9B%B6%E6%96%B0%E5%BB%BAreact%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B%E5%8F%8A%E9%87%87%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>webpack已经升级到4+版本，无论是create-react-app还是antd-pro要么太重，要么不方便自己对webpack进行配置，因此采用从零开始的方式进行react项目搭建。</p></blockquote><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>4.0版本之后，webpack的配置有了一些明显的变化<br>首先是安装：</p><pre><code>npm install --save-dev webpacknpm install --save-dev webpack-cliornpm install --save-dev webpack-command</code></pre><p>webpack被拆分到了两个包里，其中使用webpack命令，需要安装<code>webpack-cli</code>或<code>webpack-command</code></p><p>如果是全局安装，那么这样设置<code>package.json</code></p><pre><code>&quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;webpack --mode development&quot;,    &quot;build&quot;: &quot;webpack --mode production&quot;&#125;</code></pre><p>如果是项目内安装</p><pre><code>&quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;node_modules/.bin/webpack --mode development&quot;,    &quot;build&quot;: &quot;node_modules/.bin/webpack --mode production&quot;&#125;</code></pre><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol><li>react及babel相关依赖(babel新的相关包的命名方式已经改为@babel/+name的形式)</li></ol><pre><code>npm i -D @babel/core babel-loader @babel/preset-env @babel/preset-reactnpm i -S  react react-dom</code></pre><ol start="2"><li>新建webpack.config.js(webpack4.0的语法与之前差异较大，深坑)</li></ol><pre><code>module: &#123;    rules: [        &#123;            test: /\.jsx?$/,            exclude: /node_modules/,            use: [                &#123;                    loader: &#39;babel-loader&#39;,                    options: &#123;                        presets:[&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;]                    &#125;                &#125;            ]        &#125;    ]&#125;</code></pre><ol start="3"><li>index.js基础格式</li></ol><pre><code>import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;ReactDOM.render(    &lt;div&gt;Hello world&lt;/div&gt;,    document.getElementById(&quot;app&quot;));</code></pre><ol start="4"><li>使用html-webpack-plugin对html打包。</li></ol><pre><code>npm i -D html-webpack-plugin html-loader</code></pre><p>修改<code>webpack.config.js</code>配置</p><pre><code>const path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = &#123;    module: &#123;        rules: [            &#123;                test: /\.jsx?$/,                exclude: /node_modules/,                use: [                    &#123;                        loader: &#39;babel-loader&#39;,                        options: &#123;                            presets:[&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;]                        &#125;                    &#125;                ]            &#125;,&#123;                test: /\.html$/,                use: [                    &#123;                        loader: &quot;html-loader&quot;,                        options: &#123; minimize: true &#125;                    &#125;                ]            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: &#39;./public/index.html&#39;,            filename: &#39;index.html&#39;,        &#125;)    ]&#125;</code></pre><ol start="5"><li>安装<code>webpack-dev-server</code>插件</li></ol><pre><code>npm i -D webpack-dev-server</code></pre><p>修改package.json文件</p><pre><code>&quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;webpack-dev-server --mode development --open&quot;,    &quot;build&quot;: &quot;webpack --mode production&quot;&#125;,</code></pre><p>修改webpack.config.js文件</p><pre><code>const path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = &#123;    mode: &quot;development&quot;,     entry: &#39;./src/index.js&#39;,     output: &#123;        path: path.resolve(__dirname, &#39;build&#39;),        filename: &#39;index.js&#39;,    &#125;,    module: &#123;        rules: [            &#123;                test: /\.jsx?$/,                exclude: /node_modules/,                use: [                    &#123;                        loader: &#39;babel-loader&#39;,                        options: &#123;                            presets:[&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;],                        &#125;                    &#125;                ]            &#125;,&#123;                test: /\.html$/,                use: [                    &#123;                        loader: &quot;html-loader&quot;,                        options: &#123; minimize: true &#125;                    &#125;                ]            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: &#39;./public/index.html&#39;,            filename: &#39;index.html&#39;,        &#125;)    ],    devServer:&#123;        contentBase:path.join(__dirname,&quot;dist&quot;),        compress:true,        port:8888,        host:&#39;127.0.0.1&#39;,    &#125;&#125;</code></pre><ol start="6"><li>安装<code>react-hot-loader</code>插件（可选）</li></ol><p>webpack中提供了热模块更新的功能，在不刷新整个页面的情况下来替换某些更变的组件，而这样做的最大的好处就在于状态的保存。比如我们前面在输入框中输入的内容，就不会在我们热模块替换以后被刷新掉，让我们要重新再输入一次了。</p><p>安装插件</p><pre><code>npm i -D react-hot-loader</code></pre><p>修改<code>webpack.config.js</code></p><pre><code>const path = require(&#39;path&#39;);const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);module.exports = &#123;    mode: &quot;development&quot;,     entry: &#39;./src/index.js&#39;,     output: &#123;            path: path.resolve(__dirname, &#39;build&#39;),            filename: &#39;index.js&#39;,    &#125;,    module: &#123;        rules: [            &#123;                test: /\.jsx?$/,                exclude: /node_modules/,                use: [                    &#123;                        loader: &#39;babel-loader&#39;,                        options: &#123;                            presets:[&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;],                            plugins: [&#39;react-hot-loader/babel&#39;],                        &#125;                    &#125;                ]            &#125;,&#123;                test: /\.html$/,                use: [                    &#123;                        loader: &quot;html-loader&quot;,                        options: &#123; minimize: true &#125;                    &#125;                ]            &#125;        ]    &#125;,    plugins: [        new HtmlWebpackPlugin(&#123;            template: &#39;./public/index.html&#39;,            filename: &#39;index.html&#39;,        &#125;)    ],    devServer:&#123;        contentBase:path.join(__dirname,&quot;dist&quot;),        compress:true,        port:8888,        host:&#39;127.0.0.1&#39;,    &#125;&#125;</code></pre><p>修改<code>./index.js</code></p><pre><code>import React from &#39;react&#39;;import ReactDom from &#39;react-dom&#39;;import &#123; AppContainer &#125; from &#39;react-hot-loader&#39;import App from &#39;./app&#39;;const render = Component =&gt; &#123;      ReactDom.render(        &lt;AppContainer&gt;            &lt;Component /&gt;        &lt;/AppContainer&gt;,        document.getElementById(&#39;root&#39;)    )&#125;render(App);if (module.hot) &#123;    module.hot.accept(&#39;./app&#39;, () =&gt; &#123; render(App) &#125;)&#125;</code></pre><p>修改package.json，加入<code>--hot</code>参数启动<code>react-hot-loader</code></p><pre><code>&quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;webpack-dev-server --hot --mode development --open&quot;,&#125;,</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用nrm来管理npm的源</title>
      <link href="2018/11/17/nrm/"/>
      <url>2018/11/17/nrm/</url>
      
        <content type="html"><![CDATA[<p>在日常中，存在很多需要切换npm源的情况，通过nrm可以方便的切换npm的源。</p><span id="more"></span><h2 id="nrm使用"><a href="#nrm使用" class="headerlink" title="nrm使用"></a>nrm使用</h2><ol><li><p>安装</p><pre><code>sudo npm install -g nrm</code></pre></li><li><p>查看nrm命令或者帮助文档</p><pre><code>nrm -h</code></pre><pre><code>Usage: nrm [options] [command]Commands: ls                           List all the registries current                      Show current registry name use &lt;registry&gt;               Change registry to registry add &lt;registry&gt; &lt;url&gt; [home]  Add one custom registry del &lt;registry&gt;               Delete one custom registry home &lt;registry&gt; [browser]    Open the homepage of registry with optional browser test [registry]              Show response time for specific or all registries help                         Print this helpOptions: -h, --help     output usage information -V, --version  output the version number</code></pre></li><li><p>常用命令<br><code>nrm ls</code> 查看已有的源<br><code>nrm add &lt;源名称&gt; &lt;源地址&gt;</code> 新增源<br><code>nrm use &lt;源名称&gt;</code> 切换源</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo简单使用配置</title>
      <link href="2018/08/03/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>2018/08/03/hexo%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><code>next</code>主题非常的火爆，<br>(<code>next</code>主题文档)[<a href="http://theme-next.iissnan.com/third-party-services.html]" target="_blank" rel="noopener">http://theme-next.iissnan.com/third-party-services.html]</a></p><p>如果部署Github Page,每次部署的时候，都需要重新设置<code>domain</code>，这时候只需要新建一个<code>CNAME</code>文件，将重定向的<code>url</code>写入，并将这个文件放在<code>theme</code>内的<code>source</code>文件夹内即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
